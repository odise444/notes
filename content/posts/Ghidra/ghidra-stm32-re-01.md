---
title: "Ghidra로 STM32 부트로더 역분석한 썰 #1 - 왜 역분석을 하게 됐나"
date: 2024-12-09
draft: false
tags: ["Ghidra", "STM32", "리버스엔지니어링", "역분석", "부트로더", "BMS"]
categories: ["역분석"]
summary: "소스코드가 없다. HEX 파일만 있다. 현장에서 펌웨어 업데이트를 해야 한다. 어떻게?"
---

## 상황

회사에서 BMS 제품을 인수했다. 72V 리튬이온 배터리 관리 시스템.

받은 것:
- ✅ 완제품 10대
- ✅ 회로도 (PDF)
- ✅ HEX 파일 (펌웨어)
- ❌ 소스코드 → **없음!**

## 문제 발생

현장에 설치된 장비에서 버그가 발견됐다. 펌웨어 수정이 필요한데...

```
개발자: "소스코드 주세요"
전 담당자: "퇴사했어요"
서버: "백업 없음"
Git: "뭐요?"
```

**소스코드 증발.** 실화다.

## 선택지

1. **처음부터 다시 개발** - 6개월+ 소요, 비용 큼
2. **버그 무시** - 고객 클레임 감수
3. **역분석으로 복원** - ???

3번을 선택했다. 어차피 펌웨어는 있으니까.

## 다행히 있던 것들

### 부트로더 HEX 파일

```
200429.hex - 16KB 부트로더
```

CAN 통신으로 펌웨어 업데이트하는 기능이 있다고 한다. 프로토콜 문서? 없다.

### 애플리케이션 헤더 파일 일부

기적적으로 일부 .h 파일이 남아있었다:

```c
/* PC → BMS (0x5FF) */
#define IAP_BMS_P2B_CONN_KEY_REQ      0x30
#define IAP_BMS_P2B_CONN_KEYCAL_REQ   0x31
#define IAP_BMS_P2B_SIZE_RES          0x32
...

/* BMS → PC (0x5FE) */
#define IAP_BMS_B2P_CONN_KEY_RES      0x40
#define IAP_BMS_B2P_CONN_OK           0x41
...
```

프로토콜 명령 코드는 알겠는데, **구현 로직**을 모른다.

### PC 업로더 프로그램

윈도우용 펌웨어 업로더 EXE가 있었다. CAN 어댑터로 펌웨어 올리는 프로그램.

**하지만**: 이것도 소스 없음. 실행만 됨.

## 목표 설정

1. **부트로더 프로토콜 파악** - CAN IAP 통신 구조 이해
2. **Connection Key 알고리즘** - 인증 로직 해독
3. **Python 업로더 제작** - 기존 EXE 대체
4. **(보너스) 부트로더 소스 복원** - 유지보수용

## 왜 Ghidra인가

### IDA Pro

업계 표준이지만 **비싸다**. 라이선스 수백만원.

### Ghidra

NSA에서 2019년 공개한 **무료** 리버스 엔지니어링 도구.

- ARM Cortex-M 지원 ✅
- 디컴파일러 내장 ✅
- 무료 ✅

```
가격: $0
품질: IDA Pro 90% 수준
결론: 이거다
```

## 분석 대상 파악

ST-Link로 플래시 덤프를 떠서 확인:

```
0x08000000 ~ 0x08003FFF: 부트로더 (16KB)
0x08004000 ~ 0x08041FFF: 버퍼 영역 (254KB)
0x08042800 ~ 0x0807FFFF: 애플리케이션 (246KB)
```

**메모리 맵 구조:**

```
┌─────────────────────┐ 0x08080000
│                     │
│    Application      │
│      (246KB)        │
│                     │
├─────────────────────┤ 0x08042800
│                     │
│    Buffer           │
│    (펌웨어 수신용)   │
│      (254KB)        │
│                     │
├─────────────────────┤ 0x08004000
│    Bootloader       │
│      (16KB)         │
└─────────────────────┘ 0x08000000
```

## CAN 스니핑으로 힌트 얻기

기존 EXE 업로더를 실행하면서 CAN 버스 스니핑:

```
PC → BMS (0x5FF): 30 00 00 00 00 00 00 00
BMS → PC (0x5FE): 40 12 34 56 78 20 04 29
PC → BMS (0x5FF): 31 XX XX XX XX 00 00 00
BMS → PC (0x5FE): 41 00 00 00 00 00 00 00
...
```

**발견한 것:**
- `0x30` → `0x40`: Connection 요청/응답
- `0x40` 응답에 `20 04 29` → 날짜? (2020-04-29)
- `0x31`로 뭔가 계산값 보냄 → **이게 뭐지?**

## 역분석 시작

스니핑만으로는 한계. 부트로더 바이너리를 직접 분석해야 한다.

```bash
# HEX → BIN 변환
objcopy -I ihex -O binary 200429.hex 200429.bin

# Ghidra 실행
ghidraRun
```

**다음 글에서**: Ghidra에 바이너리 로드하고 첫 분석 시작.

## 교훈

1. **소스코드 백업은 필수** - Git, NAS, 클라우드 어디든
2. **문서화** - 프로토콜, 메모리 맵 등
3. **인수인계** - 담당자 퇴사 전 확인
4. **역분석은 최후의 수단** - 시간 많이 든다

그래도 HEX 파일이라도 있어서 다행이다. 진짜 아무것도 없었으면...

---

## 시리즈 목차

1. **왜 역분석을 하게 됐나** ← 현재 글
2. HEX 파일 구조 이해하기
3. Ghidra 설치와 첫 로드
4. 디스어셈블리 vs 디컴파일
5. Vector Table 분석
6. ...

---

## 분석 대상 스펙

| 항목 | 값 |
|------|-----|
| MCU | STM32F103VE |
| Flash | 512KB |
| RAM | 64KB |
| 부트로더 | 16KB |
| CAN | 500kbps |
| CAN ID | 0x5FF (RX), 0x5FE (TX) |
